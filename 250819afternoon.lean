import Mathlib

/-
## Hierarchies

Structures can be organized into hierarchies, where more complex structures extend simpler ones. For example, a `Group` is a `Monoid` adding an inverse operation and the corresponding axioms. Hierarchies are useful because they allow us to reuse definitions and theorems. For instance, it would be convienient if any theorem about monoids automatically applies to groups.

At the very bottom of all hierarchies in Lean, we find data-carrying classes. The following class records that the given type `α` is endowed with a distinguished element called `one`. At this stage, it has no property at all.
-/

class One₁ (α : Type) where
  /-- The element one -/
  one : α

/-
The `class` command above defines a structure `One₁` with parameter `α : Type` and a single field `one`. It also marks this structure as a class so that arguments of type `One₁ α` for some type `α` will be inferrable using the instance resolution procedure.
-/

example (α : Type) [One₁ α] : α := One₁.one

/-
Our next task is to assign a notation to `One₁.one`. Since we don’t want collisions with the builtin notation for `1`, we will use `𝟙`. This is achieved by the following command where the first line tells Lean to use the documentation of `One₁.one` as documentation for the symbol `𝟙`.
-/

notation "𝟙" => One₁.one

example {α : Type} [One₁ α] : α := 𝟙

example {α : Type} [One₁ α] : (𝟙 : α) = 𝟙 := rfl

/-
We now want a data-carrying class recording a binary operation. We don’t want to choose between addition and multiplication for now so we’ll use diamond.
-/

class Dia₁ (α : Type) where
  dia : α → α → α

infixl:70 " ⋄ "   => Dia₁.dia

/-
As in the `One₁` example, the operation has no property at all at this stage. Let us now define the class of semigroup structures where the operation is denoted by `⋄`. For now, we define it by hand as a structure with two fields, a `Dia₁` instance and some `Prop`-valued field `dia_assoc` asserting associativity of `⋄`.

We would like to tell Lean that `Dia₁ α` should be treated as if its fields were fields of `Semigroup₁` itself. This also conveniently adds the `toDia₁` instance automatically. The `class` command supports this using the `extends` syntax as in:
-/

class Semigroup₁ (α : Type) extends Dia₁ α where
  /-- Diamond is associative -/
  dia_assoc : ∀ a b c : α, a ⋄ b ⋄ c = a ⋄ (b ⋄ c)

/-
We can only have the expression `a ⋄ b` if there is an instance of `Dia₁ α` for the type `α`.
-/
example {α : Type} [Dia₁ α] (a b : α) : α := a ⋄ b

/-
With `Semigroup₁ α`, Lean can also synthesize `Dia₁ α` for the type `α`, as a result, we can use the `⋄` operator too. This synthesis process is achieved by `Semigroup₁.toDia₁`.
-/
example {α : Type} [Semigroup₁ α] (a b : α) : α := a ⋄ b

#check Semigroup₁.toDia₁

class Semigroup₂ (α : Type) extends otDia₁ : Dia₁ α where
  dia_assoc : ∀ a b c : α, a ⋄ b ⋄ c = a ⋄ (b ⋄ c)

-- #check Semigroup₂.toDia₁
#check Semigroup₂.otDia₁

/-
Note this syntax is also available in the `structure` command.

The field name `toDia₁` is optional in the `extends` syntax. By default it takes the name of the class being extended and prefixes it with “to”.

------

Let us now try to combine a diamond operation and a distinguished one element with axioms saying this element is neutral on both sides.
-/

class DiaOneClass₁ (α : Type) extends One₁ α, Dia₁ α where
  /-- One is a left neutral element for diamond. -/
  one_dia : ∀ a : α, 𝟙 ⋄ a = a
  /-- One is a right neutral element for diamond -/
  dia_one : ∀ a : α, a ⋄ 𝟙 = a

/-
In the next example, we tell Lean that `α` has a `DiaOneClass₁` structure and state a property that uses both a `Dia₁` instance and a `One₁` instance.

In order to see how Lean finds those instances we set a tracing option whose result can be seen in the Infoview. This result is rather terse by default but it can be expanded by clicking on lines ending with black arrows. It includes failed attempts where Lean tried to find instances before having enough type information to succeed. The successful attempts do involve the instances generated by the `extends` syntax.
-/

set_option trace.Meta.synthInstance true in
example {α : Type} [DiaOneClass₁ α] (a b : α) : Prop := a ⋄ b = 𝟙

/-
Note that we don’t need to include extra fields where combining existing classes. Hence we can define monoids as:
-/

class Monoid₁ (α : Type) extends Semigroup₁ α, DiaOneClass₁ α

/-
While the above definition seems straightforward, it hides an important subtlety. Both `Semigroup₁ α` and `DiaOneClass₁ α` extend `Dia₁ α`, so one could fear that having a `Monoid₁ α` instance gives two unrelated diamond operations on `α`, one coming from a field `Monoid₁.toSemigroup₁` and one coming from a field `Monoid₁.toDiaOneClass₁`.

Indeed if we try to build a monoid class by hand using:
-/

class Monoid₂ (α : Type) where
  toSemigroup₁ : Semigroup₁ α
  toDiaOneClass₁ : DiaOneClass₁ α

/-
then we get two completely unrelated diamond operations `Monoid₂.toSemigroup₁.toDia₁.dia` and `Monoid₂.toDiaOneClass₁.toDia₁.dia`.

The version generated using the `extends` syntax does not have this problem.
-/

example {α : Type} [Monoid₁ α] :
  (Monoid₁.toSemigroup₁.toDia₁.dia : α → α → α) = Monoid₁.toDiaOneClass₁.toDia₁.dia := rfl

/- Monoid₂.mk {α : Type} (toSemigroup₁ : Semigroup₁ α) (toDiaOneClass₁ : DiaOneClass₁ α) : Monoid₂ α -/
#check Monoid₂.mk

/- Monoid₁.mk {α : Type} [toSemigroup₁ : Semigroup₁ α] [toOne₁ : One₁ α] (one_dia : ∀ (a : α), 𝟙 ⋄ a = a) (dia_one : ∀ (a : α), a ⋄ 𝟙 = a) : Monoid₁ α -/
#check Monoid₁.mk

/-
So we see that `Monoid₁` takes `Semigroup₁ α` argument as expected but then it won’t take a would-be overlapping `DiaOneClass₁ α` argument but instead tears it apart and includes only the non-overlapping parts.

And it also auto-generated an instance `Monoid₁.toDiaOneClass₁` which is not a field but has the expected signature which, from the end-user point of view, restores the symmetry between the two extended classes `Semigroup₁` and `DiaOneClass₁`.
-/

#check Monoid₁.toSemigroup₁
#check Monoid₁.toDiaOneClass₁

/-
We are now very close to defining groups. We could add to the monoid structure a field asserting the existence of an inverse for every element. But then we would need to work to access these inverses. In practice it is more convenient to add it as data. To optimize reusability, we define a new data-carrying class, and then give it some notation.
-/

class Inv₁ (α : Type) where
  /-- The inversion function -/
  inv : α → α

postfix:max "⁻¹" => Inv₁.inv

class Group₁ (G : Type) extends Monoid₁ G, Inv₁ G where
  inv_dia : ∀ a : G, a⁻¹ ⋄ a = 𝟙

/-
The above definition may seem too weak, we only ask that `a⁻¹` is a left-inverse of `a`. But the other side is automatic. In order to prove that, we need a preliminary lemma.
-/

open DiaOneClass₁ Semigroup₁ Group₁

lemma left_inv_eq_right_inv₁ {M : Type} [Monoid₁ M] {a b c : M} (hba : b ⋄ a = 𝟙) (hac : a ⋄ c = 𝟙) : b = c := by
  rw [← one_dia c, ← hba, dia_assoc, hac, dia_one b]

lemma inv_eq_of_dia {G : Type} [Group₁ G] {a b : G} (h : a ⋄ b = 𝟙) : a⁻¹ = b :=
  sorry

lemma dia_inv {G : Type} [Group₁ G] (a : G) : a ⋄ a⁻¹ = 𝟙 :=
  sorry

/-
The hierarchies also work for the case of structures.

For example, we can define `Point3D`, `Point2DUpperHalfPlane`, `Point3DUpperHalfSpace` on the basis of `Point2D`.
-/

structure Point2D where
  x : ℝ
  y : ℝ

structure Point3D extends Point2D where
  z : ℝ

structure Point2DUpperHalfPlane extends Point2D where
  inUpperHalfPlane : 0 ≤ y

structure Point3DUpperHalfSpace extends Point3D, Point2DUpperHalfPlane where

#check Point3DUpperHalfSpace.mk
#check Point3DUpperHalfSpace.toPoint3D
#check Point3DUpperHalfSpace.toPoint2DUpperHalfPlane


/-
Exercise: Based on the natrual langauge description, define the hierarchies of order structures.
-/

namespace exercise

/--
The class for binary relation called `le` (less than or equal to), using notation `≼`.
-/
class LE (α : Type*) where
  le : α → α → Prop

/- Type `≤` using `\preceq`. -/
infixl:70 " ≤ "   => exercise.LE.le

/--
A preorder is a reflexive and transitive relation `≼`.
Make this structure extends LE.
-/
class PreOrder (α : Type*) extends LE α where
  reflexive : ∀ a, α : a ≤ a
  transitive : ∀ a, b, c, α : a ≤ b ∧ b ≤ c → a ≤ c
/--
A partial order is an antisymmetric preorder.
-/
class PartialOrder (α : Type*) extends PreOrder where
  antisymmetric : ∀ a, b, α : a ≤ b ∧ b ≤ a → a = b
/--
A linear order is a total partial order. (i.e. for any two elements, either `a ≼ b` or `b ≼ a` holds.)
-/
class LinearOrder (α : Type*)
  
/-
Show that for any three elements `a`, `b` and `c` in a linear order, if the negation of `a ≼ b` and `b ≼ c` hold, then `c ≼ a` holds. The starting part is given below.
-/
-- theorem le_of_not_le_of_not_le {α : Type*} [LinearOrder α] {a b : α} :
--     ¬ a ≼ b → ¬ b ≼ c → c ≼ a := by 

/--
Show that the usual order "≤" on ℤ is a valid instance of the LinearOrder structure you defined above. The starting part is given below.
-/
instance Int.linearOrder : LinearOrder ℤ where
  -- le a b := a ≤ b
  -- ...

end exercise
